#Function grouping gateware build rules for DFX (partial FPGA reconfiguration) project builds. This function is only called in Vivado builds, not Verilator.
#TOP_MODULE: name of top module, e.g. ibex_soc
#PROJECT_NAME: project name, e.g. dfx_test
#VS_INSTS: DFX virtual socket instance names, e.g. boxlambda_soc/vs0_inst.
#VS_DEFAULT_COMPONENTS: DFX virtual socket default components, one for each VS_INST listed. The default component gets placed into the virtual socket in the default bitstream image, e.g. vs0_stub.

function (gw_project_rules_dfx_vivado)
  set(options)
  set(oneValueArgs TOP_MODULE PROJECT_NAME)
  set(multiValueArgs VS_INSTS VS_DEFAULT_COMPONENTS)

  cmake_parse_arguments(gw_project_rules_dfx_vivado
        "${options}"
        "${oneValueArgs}"
        "${multiValueArgs}"
        ${ARGN}
    )

  set(_top_module ${gw_project_rules_dfx_vivado_TOP_MODULE})
  set(_prj_name ${gw_project_rules_dfx_vivado_PROJECT_NAME})
  set(_vs_insts ${gw_project_rules_dfx_vivado_VS_INSTS})
  set(_vs_default_comps ${gw_project_rules_dfx_vivado_VS_DEFAULT_COMPONENTS})

  if (BL_TARGET_FPGA STREQUAL "arty-a7-100")
    set(_board arty_a7_100t)
  else()
    set(_board arty_a7_35t)
  endif()

  # Extract .mem files from Bender.yml manifest.
  add_custom_command(
        OUTPUT
            ${_prj_name}.mem_file_list
        COMMAND
            ${PROJECT_SOURCE_DIR}/scripts/bender_gen_mem_file_list.sh ${CMAKE_CURRENT_LIST_DIR} ${_prj_name}.mem_file_list vivado
        DEPENDS
            always_rebuild
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        COMMENT
            "Generating mem file list."
        VERBATIM
    )

  # Retrieve the project constraints file from the Bender.yml manifest.
  add_custom_command(
        OUTPUT
            ${_prj_name}.prj_constraints_file_list
        COMMAND
            ${PROJECT_SOURCE_DIR}/scripts/bender_gen_prj_constraints_file_list.sh ${CMAKE_CURRENT_LIST_DIR} ${_prj_name}.prj_constraints_file_list ${BL_TARGET_FPGA}
        DEPENDS
            always_rebuild
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        COMMENT
            "Generating prj_constraints file list."
        VERBATIM
    )

  #Build rules, shared with gateware components : lint target, Vivado synthesis
  gw_common_rules_vivado(
        TOP_MODULE
            ${_top_module}
        PRJ_COMP_NAME
            ${_prj_name}
        OOC
            "0"
        MEM_FILE_LIST
            ${_prj_name}.mem_file_list
        PRJ_CONSTRAINTS_FILE_LIST
            ${_prj_name}.prj_constraints_file_list
    )

  set(defaultDcps "")
  set(default_comps_synth "")
  foreach(default_comp ${_vs_default_comps})
    list(APPEND defaultDcps $<TARGET_PROPERTY:${default_comp}_synth,BINARY_DIR>/project.runs/synth_1/*.dcp)
    list(APPEND default_comps_synth ${default_comp}_synth)
  endforeach()

  foreach(defaultDcp ${defaultDcps})
    message("defaultDcp " ${defaultDcp})
  endforeach()

  #Build Vivado command string for the vivado_impl tcl script.
  #The .dcp file referenced below is the Vivado synthesis checkpoint.
  #The bender command referenced below extracts the DFX constraints file from the Bender.yml manifest/
  vivado_cmd(impl_cmd ${PROJECT_SOURCE_DIR}/scripts/vivado_impl_dfx_prj.tcl
        -vsCellInsts \"${_vs_insts}\"
        -vsDefaultDcps \"${defaultDcps}\"
        -vsPblockConstr `${PROJECT_SOURCE_DIR}/scripts/bender_get_constraints.sh ${CMAKE_CURRENT_LIST_DIR} dfx_constraints vivado`)

  #Custom command executing the vivado implementation command string.
  #Note that in the dependencies, both the _synth build rule and the .dcp synthesis checkpoint file
  #(generated by that _synth build rule) of the default VS0 component need to be specified, 
  #just one or the other is not sufficient.
  add_custom_command(
        OUTPUT
            dfx_project.bin
            dfx_project.static_route.dcp
        COMMAND
            bash -c ${impl_cmd} 2>&1 | tee impl.log
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        DEPENDS
            ${CMAKE_CURRENT_BINARY_DIR}/project.runs/synth_1/${_top_module}.dcp
            ${default_comps_synth}
            ${defaultDcps}
        COMMENT
            "Implementing DFX project and generating bitstream(s)."
        VERBATIM
    )

  #Add the bitstream generation target to make all (ALL property).
  add_custom_target(${_prj_name}_bit
        ALL
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        DEPENDS
            dfx_project.bin
        COMMENT
            "DFX project implementation and bitstream generation target."
    )

  #Note that unlike non-DFX project builds, DFX builds currently don't have a
  #_bit_sw build rule. This might be added in the future.

  #Custom command executing the vivado prg_bitstream command string.
  add_custom_target(${_prj_name}_load
          WORKING_DIRECTORY
              ${CMAKE_CURRENT_BINARY_DIR}
          COMMAND
              ${PROJECT_SOURCE_DIR}/scripts/load_gw.sh ${_board} dfx_project.bit.bin
          COMMENT
              "Loading bitstream to target."
          VERBATIM
      )

  #Custom command executing the vivado flash_bitstream command string.
  add_custom_target(${_prj_name}_flash_gw
          WORKING_DIRECTORY
              ${CMAKE_CURRENT_BINARY_DIR}
          COMMAND
              ${PROJECT_SOURCE_DIR}/scripts/flash_gw.sh ${_board} dfx_project.bit.bin
          COMMENT
              "Flashing bitstream to target."
          VERBATIM
      )
endfunction()

#Function grouping gateware project build rules for Vivado builds.
#TOP_MODULE: name of top module, e.g. ibex_soc
#PROJECT_NAME: project name, e.g. hello_dbg
#MEM_FILE_TARGET: name of the SW target that generates the required .mem file, e.g. picolibc_test
function (gw_project_rules_vivado)
  set(options)
  set(oneValueArgs TOP_MODULE PROJECT_NAME MEM_FILE_TARGET)
  set(multiValueArgs)

  cmake_parse_arguments(gw_project_rules_vivado
        "${options}"
        "${oneValueArgs}"
        "${multiValueArgs}"
        ${ARGN}
    )

  set(_top_module ${gw_project_rules_vivado_TOP_MODULE})
  set(_prj_name ${gw_project_rules_vivado_PROJECT_NAME})
  set(_mem_file_tgt ${gw_project_rules_vivado_MEM_FILE_TARGET})

  if (BL_TARGET_FPGA STREQUAL "arty-a7-100")
    set(_board arty_a7_100t)
  else()
    set(_board arty_a7_35t)
  endif()

  #Extract .mem files from Bender.yml manifest.
  add_custom_command(
        OUTPUT
            ${_prj_name}.mem_file_list
        COMMAND
            ${PROJECT_SOURCE_DIR}/scripts/bender_gen_mem_file_list.sh ${CMAKE_CURRENT_LIST_DIR} ${_prj_name}.mem_file_list vivado
        DEPENDS
            always_rebuild
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        COMMENT
            "Generating mem file list."
        VERBATIM
    )

  #Extract project constraints file from Bender.yml manifest.
  add_custom_command(
        OUTPUT
            ${_prj_name}.prj_constraints_file_list
        COMMAND
            ${PROJECT_SOURCE_DIR}/scripts/bender_gen_prj_constraints_file_list.sh ${CMAKE_CURRENT_LIST_DIR} ${_prj_name}.prj_constraints_file_list ${BL_TARGET_FPGA}
        DEPENDS
            always_rebuild
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        COMMENT
            "Generating prj_constraints file list."
        VERBATIM
    )

  #Build rules, shared with gateware components : lint target, Vivado synthesis
  gw_common_rules_vivado(
        TOP_MODULE
            ${_top_module}
        PRJ_COMP_NAME
            ${_prj_name}
        OOC
            "0"
        MEM_FILE_LIST
            ${_prj_name}.mem_file_list
        PRJ_CONSTRAINTS_FILE_LIST
            ${_prj_name}.prj_constraints_file_list
    )

  #Build Vivado command string for the vivado_impl tcl script.
  vivado_cmd(impl_cmd ${PROJECT_SOURCE_DIR}/scripts/vivado_impl.tcl)

  #Custom command executing the vivado implementation command string.
  add_custom_command(
        OUTPUT
            project.bin
        COMMAND
            bash -c ${impl_cmd} 2>&1 | tee impl.log
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        DEPENDS
            ${CMAKE_CURRENT_BINARY_DIR}/project.runs/synth_1/${_top_module}.dcp
        COMMENT
            "Implementing project and generating bitstream(s)."
        VERBATIM
    )

  #Add the bitstream generation target to make all (ALL property).
  add_custom_target(${_prj_name}_bit
        ALL
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        DEPENDS
            project.bin
        COMMENT
            "Project implementation and bitstream generation target."
    )

  if (NOT ${_mem_file_tgt} STREQUAL "")
    #Custom command updating the SW memory file in the bitstream.
    add_custom_command(
            OUTPUT
                project.sw.bit
            WORKING_DIRECTORY
                ${CMAKE_CURRENT_BINARY_DIR}
            COMMAND
                ${PROJECT_SOURCE_DIR}/scripts/vivado_updatemem.sh project.mmi $<TARGET_FILE:${_mem_file_tgt}>.mem project.bit project.sw.bit
            DEPENDS
                ${_mem_file_tgt}
                ${_prj_name}_bit
            COMMENT
                "Updating SW memory image in bitstream."
            VERBATIM
        )

    #Custom command converting the bitstream file into a .bin file ready for flashing.
    add_custom_command(
            OUTPUT
                project.sw.bit.bin
            WORKING_DIRECTORY
                ${CMAKE_CURRENT_BINARY_DIR}
            COMMAND
                ${PROJECT_SOURCE_DIR}/scripts/bit2bin.sh project.sw.bit
            DEPENDS
                project.sw.bit
            COMMENT
                "Converting bitstream to .bin."
            VERBATIM
        )

    #Add the bitstream-with-sw-image target
    add_custom_target(${_prj_name}_bit_sw
            ALL
            WORKING_DIRECTORY
                ${CMAKE_CURRENT_BINARY_DIR}
            DEPENDS
                project.sw.bit.bin
            COMMENT
                "Bitstream + SW image target."
        )

    set(_bit_file project.sw.bit)
  else()
    set(_bit_file project.bit)
  endif()

  #Custom command executing the vivado prg_bitstream command string.
  add_custom_target(${_prj_name}_load
          WORKING_DIRECTORY
              ${CMAKE_CURRENT_BINARY_DIR}
          COMMAND
              ${PROJECT_SOURCE_DIR}/scripts/load_gw.sh ${_board} ${_bit_file}
          COMMENT
              "Loading bitstream to target."
          VERBATIM
      )

  #Custom command executing the vivado flash_bitstream command string.
  add_custom_target(${_prj_name}_flash_gw
          WORKING_DIRECTORY
              ${CMAKE_CURRENT_BINARY_DIR}
          COMMAND
              ${PROJECT_SOURCE_DIR}/scripts/flash_gw.sh ${_board} ${_bit_file}.bin
          COMMENT
              "Flashing bitstream to target."
          VERBATIM
      )
endfunction()

#Function grouping gateware project build rules for OpenXC7 builds.
#TOP_MODULE: name of top module, e.g. ibex_soc.
#PROJECT_NAME: project name, e.g. hello_dbg.
#FREQ: target frequency (Most likely 50 (MHz)).
function (gw_project_rules_openxc7)
  set(options)
  set(oneValueArgs TOP_MODULE PROJECT_NAME FREQ MEM_FILE_TARGET)

  cmake_parse_arguments(gw_project_rules_openxc7
        "${options}"
        "${oneValueArgs}"
        "${multiValueArgs}"
        ${ARGN}
    )

  set(_top_module ${gw_project_rules_openxc7_TOP_MODULE})
  set(_prj_name ${gw_project_rules_openxc7_PROJECT_NAME})
  set(_freq ${gw_project_rules_openxc7_FREQ})

  gw_common_rules_openxc7(
        TOP_MODULE
            ${_top_module}
        PRJ_COMP_NAME
            ${_prj_name}
  )

  #Custom command executing the openXC7 implementation script
  add_custom_command(
        OUTPUT
            ${_top_module}.bin
            ${_top_module}_routed.json
        COMMAND
            bash -c "${PROJECT_SOURCE_DIR}/scripts/openxc7_impl.sh ${PART} `${PROJECT_SOURCE_DIR}/scripts/bender_get_constraints.sh ${CMAKE_CURRENT_LIST_DIR} prj_constraints openxc7` ${_top_module} ${_freq}"
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        DEPENDS
            ${CMAKE_CURRENT_BINARY_DIR}/${_top_module}.json
        COMMENT
            "Implementing OpenXC7 project and generating bitstream(s)."
        VERBATIM
    )

  #Add the bitstream generation target to make all (ALL property).
  add_custom_target(${_prj_name}_bit
        ALL
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        DEPENDS
            ${_top_module}.bin
        COMMENT
            "OpenXC7 project implementation and bitstream generation target."
    )

endfunction()

#Function grouping gateware project build rules for Verilator builds.
#TOP_MODULE: name of top module, e.g. ibex_soc
#PROJECT_NAME: project name, e.g. hello_dbg
#MEM_FILE_TARGET: name of the SW target that generates the required .mem file, e.g. picolibc_test
#VERILATOR_FLAGS: CFLAGS and LDFLAGS to use when verilating. Prepend each CFLAG with "-CFLAG" and each LDFLAG with "-LDFLAG".

function (gw_project_rules_verilator)
  set(options)
  set(oneValueArgs TOP_MODULE PROJECT_NAME MEM_FILE_TARGET)
  set(multiValueArgs VERILATOR_FLAGS)

  cmake_parse_arguments(gw_project_rules_verilator
        "${options}"
        "${oneValueArgs}"
        "${multiValueArgs}"
        ${ARGN}
    )

  set(_top_module ${gw_project_rules_verilator_TOP_MODULE})
  set(_prj_name ${gw_project_rules_verilator_PROJECT_NAME})
  set(_mem_file_tgt ${gw_project_rules_verilator_MEM_FILE_TARGET})
  set(_verilator_flags ${gw_project_rules_verilator_VERILATOR_FLAGS})

  #Extract .mem files from the Bender.yml manifest.
  add_custom_command(
        OUTPUT
            ${_prj_name}.mem_file_list
        COMMAND
            ${PROJECT_SOURCE_DIR}/scripts/bender_gen_mem_file_list.sh ${CMAKE_CURRENT_LIST_DIR} ${_prj_name}.mem_file_list verilator
        DEPENDS
            always_rebuild
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        COMMENT
            "Generating mem file list."
        VERBATIM
    )

  #Build rules, shared with gateware components : lint target, Vivado synthesis
  gw_common_rules_verilator(
        TOP_MODULE
            ${_top_module}
        PRJ_COMP_NAME
            ${_prj_name}
        VERILATOR_FLAGS
            ${_verilator_flags}
    )

  #Extract .c and .cpp files from Bender.yml manifest.
  add_custom_command(
        OUTPUT
            ${_prj_name}.cpp_files
        COMMAND
            ${PROJECT_SOURCE_DIR}/scripts/bender_get_cpp_files.sh ${CMAKE_CURRENT_LIST_DIR} ${_prj_name}.cpp_files ${BL_TARGET_FPGA}
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        DEPENDS
            always_rebuild
        COMMENT
            "Retrieving CPP files for Verilator build."
        VERBATIM
    )

  add_custom_command(
        OUTPUT
            Vmodel
        COMMAND
            ${PROJECT_SOURCE_DIR}/scripts/verilator_sim.sh ${_prj_name}.verilator_sources ${_prj_name}.vlts ${_prj_name}.cpp_files ${_top_module} ${CMAKE_CURRENT_BINARY_DIR} ${_verilator_flags}
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        DEPENDS
            ${_prj_name}.mem_file_list
            ${_prj_name}.verilator_sources
            ${_prj_name}.vlts
            ${_prj_name}.cpp_files
        DEPFILE
            ${_prj_name}.verilator_sources.dep
        COMMENT
            "Generating Verilator Vmodel."
        VERBATIM
    )

  add_custom_target(${_prj_name}_sim
        ALL
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_BINARY_DIR}
        DEPENDS
            Vmodel
        COMMENT
            "Verilator build target."
        VERBATIM
    )

  if (NOT ${_mem_file_tgt} STREQUAL "")
    #Custom command copying the SW image to its proper place in the gateware build directory
    add_custom_command(
            OUTPUT
                cmem.mem
            WORKING_DIRECTORY
                ${CMAKE_CURRENT_BINARY_DIR}
            COMMAND
                cp $<TARGET_FILE:${_mem_file_tgt}>.mem ${CMAKE_CURRENT_BINARY_DIR}/cmem.mem
            DEPENDS
                ${_mem_file_tgt}
            COMMENT
                "Copying SW memory image to gateware build dir."
            VERBATIM
        )

    #Verilator model + SW image target
    add_custom_target(${_prj_name}_sim_sw
            ALL
            WORKING_DIRECTORY
                ${CMAKE_CURRENT_BINARY_DIR}
            DEPENDS
                cmem.mem
                ${_prj_name}_sim
            COMMENT
                "Verilator Vmodel + SW image target."
        )
  endif()
endfunction()

add_subdirectory(hello_world)
add_subdirectory(ddr_test)
add_subdirectory(vera_integrated)
add_subdirectory(sdspi_test)
add_subdirectory(fatfs_test)
add_subdirectory(audio_dac_test)
add_subdirectory(ym2149_dac_test)
if (BL_TARGET_FPGA STREQUAL "arty-a7-100")
  add_subdirectory(stsound_test)
endif()
add_subdirectory(picorv_dma_sys_test_ext)
add_subdirectory(dual_port_ram_test)
add_subdirectory(usb_hid_sys_test)
add_subdirectory(spiflash_test)
add_subdirectory(timer_uart_gpio_irqs)
add_subdirectory(i2c_test)
if ((CMAKE_BUILD_TYPE STREQUAL "vivado") OR (CMAKE_BUILD_TYPE STREQUAL "openxc7"))
  add_subdirectory(rtcc_test)
  add_subdirectory(boxlambda_base)
endif()
add_subdirectory(reset_test)
if ((CMAKE_BUILD_TYPE STREQUAL "vivado") AND (BL_TARGET_FPGA STREQUAL "arty-a7-100"))
  add_subdirectory(j1b_test)
  add_subdirectory(boxlambda_dfx)
endif()
add_subdirectory(invalid_address)


