# The Software Build Structure

## Four Layers

The software build system is organized into four layers:

1. **The Software Project Layer**:
   Example: *Hello World*. This layer represents the top level of the build system. The software ELF executables and flash binaries are built at this level. Depending on what functionality the software project build requires, it will add libraries from the *Software Component Layer*.

2. **The Software Component Layer**:
   Software Components are the building blocks of a Software Project build. Each component is built as a library and may have dependencies on additional software components in the *Software Component Layer*. The Software Component's sources are located directly in the Software Component's directory, or referenced from specific locations in the submodule layer.

3. **The Submodule Layer**:
   Submodules are Git submodules containing, among other things, source code referenced from the *Software Component Layer*. The software build system does not directly build at this level. Makefile locates in the *Submodule Layer* are not executed.

4. **The Code Generation Layer**:
   Some components require some form of transformation to be turned into source code. The component in question provides specific code generation instructions in the form of a *custom command* (`add_custom_command`) in its `CMakefile.txt`. The custom command is added as a dependency to the generic `cgen` target, which gets executed as part of `make regen`, the build tree (re-)generation command. Except the [Register Access Layer](sw_comp_register_access_layer.md), code-generated files are written to the `codegen/` subdirectory in the build tree.

The following software components currently rely on code generation:

   - **sdram**: Register macros and initialization code for the LiteDRAM module are generated from the LiteX submodule.
   - **Register Access Layer**: This layer, code-generated by Corsair, is part of the source tree, in the [registers/generated](https://github.com/epsilon537/boxlambda/tree/master/registers/generated) directory.

## The Software CMakeLists

The build system consists of a tree of `CMakeLists.txt` files. The top-level `CMakeLists.txt` adds the `gw/` and `sw/` subdirectories. The `CMakeLists.txt` files in the `sw/` directory adds the `components/` and `projects/` subdirectories, etc., down to the individual SW component and project directories.

### A Software Component CMakeList

The Software Compoonent CMakeList is straightforward: You give the library a name, specify its sources, include paths, and C/CPPFLAGS:

```
add_library(gpio)

target_sources(gpio
    PRIVATE
    gpio.cpp
)

target_compile_options(gpio
 PRIVATE
  -O2 -g -ffunction-sections
)

#Paths to include files users of usb_hid are expected to use.
target_include_directories(gpio
    PUBLIC
        ${CMAKE_CURRENT_LIST_DIR}
        ${PROJECT_SOURCE_DIR}/registers/generated/
)
```

### A Software Project CMakeList

CMake is designed to build software. The necessary functions for creating libraries, executables, etc., are predefined. The only custom function added to the software CMakeLists tree is `link_and_create_image()`. This function executes the necessary steps to link the given target using a given linker script and generate an executable and a memory file. The memory file can be used by the GW part of the build system to initialize IMEM.

A typical SW project `CMakeLists.txt` file looks like this:

```
add_executable(hello_world
 EXCLUDE_FROM_ALL
    hello.cpp
)

#Setting the -g flag for the hello_dbg build testing GDB access.
target_compile_options(hello_world
 PRIVATE -g)

if(CMAKE_BUILD_TYPE STREQUAL "sim")
  link_and_create_image(hello_world
  ${PROJECT_SOURCE_DIR}/sw/components/bootstrap/link_imem_boot.ld)
else()
  link_and_create_image(hello_world
  ${PROJECT_SOURCE_DIR}/sw/components/bootstrap/link_ddr_to_imem_boot.ld)
endif()

target_link_libraries(hello_world gpio riscv bootstrap)

add_flash_sw_target(hello_world)
```

Note that depending on whether we're building for simulation or FPGA, two variants of the linker script are used. `link_imem_boot.ld` creates an image that boots directly from IMEM. `link_ddr_to_imem_boot.ld` creates a image to be loaded into EMEM by the bootloader. From there, the image will unpack itself into IMEM.

Other linker script variants:
- [link_ddr_to_ddr_boot.ld](): Creates a image to be loaded into EMEM by the bootloader. From there, the image will unpack itself further into EMEM.
- [boxlambda_os/link.ld](): The linker script used by the BoxLambda OS. Note the Forth sections.

#### Linker Script Details

Through a *linker script*, we tell the linker where in memory to place the program code, data, and stack.

The Linker Script defines the following:

- Relevant Memories on the target device: In the case of BoxLambda, these are `imem` and `emem` (=DDR memory).
```
MEMORY
{
    imem : ORIGIN = __imem, LENGTH = __imem_size
    emem : ORIGIN = __emem, LENGTH = __emem_size
}
```
- The mapping of input to output sections. Input sections are defined in the source code and default to .text, .bss, and .data when not explicitly specified. Typical output sections for BoxLambda are: `.etext`, `.edata`, `ebss`, `.itext`, `.idata`, `.tdata`, `.tbss`, `.ibss`, `.heap`, and `.stack`.
```
    .itext : {
        ...
        /* code */
        *(.text.unlikely .text.unlikely.*)
        *(.text.startup .text.startup.*)
        *(.text .text.*)
        *(.gnu.linkonce.t.*)
        ...
```
- The mapping of output sections to memories:
```
    ...
    .itext : {...
    } >imem
    ...
    .idata : ALIGN_WITH_INPUT {...
    } >imem
    ...
    .ibss (NOLOAD) : {...
    } >imem
    ...
    .heap (NOLOAD) : {...
    } >emem
```
  - Code, Data, and BSS input sections go to `imem` or `emem` depending on their assignment to *.itext/data/bss* or *.etext/data/bss* output sections.
  - The stack typically goes to `imem`.
  - The heap goes to `emem`.
- Symbols used by the CRT0 code for section relocation, BSS initialization, etc. For BoxLambda, the key symbols are:
    - `__icode_source / __icode_start / __icode_size`: source address, destination address, and size of the IMEM code section. In the `link_imem_boot.ld` case, `__icode_source` and `__icode_start` point to the same IMEM address. In the `link_ddr_to_imem_boot.ld` case, `__icode_source` points to EMEM and `__icode_start` points to IMEM.
    - `__ecode_source / __ecode_start / __ecode_size`: source address, destination address, and size of the EMEM code section.
    - `__idata_source / __idata_start / __idata_size`: source address, destination address, and size of the IMEM data section. In the `link_imem_boot.ld` case ; `__data_source` and `__data_start` point to the same IMEM address. In the `link_ddr_to_imem_boot.ld` case ; `__idata_source` and `__idata_start` point to the same IMEM address.
    - `__edata_source / __edata_start / __edata_size`: source address, destination address, and size of the EMEM data section.
    - `__ibss_start / __ibss_size`: Address and size of BSS section in IMEM to zero out.
    - `__ebss_start / __ebss_size`: Address and size of BSS section in EMEM to zero out.
```
    .itext : {
       ...
    } >imem

    PROVIDE(__icode_end = .);
    PROVIDE( __icode_start = ADDR(.itext) );
    PROVIDE( __icode_source = ADDR(.itext) );
    PROVIDE( __icode_size = __icode_end - __icode_start );
```

### Software CMakeList Organization

![Software CMakeLists Organization.](assets/CMakeLists_sw_org.png)

*Software CMakeLists Organization.*

