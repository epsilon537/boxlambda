SHELL = /bin/bash
#TCL script interfacing the build system with Vivado
VIVADO_TCL := $(TOP_DIR)/build_sys/vivado.tcl
#TCL script for programming the bitstream using Vivado
PRG_BITSTREAM_TCL := $(TOP_DIR)/build_sys/prg_bitstream.tcl

#Currently Arty A7-35T only
PART = xc7a35ticsg324-1L
#The HDL sources script generated by Bender goes here
BENDER_GEN_SCRIPT = generated/sources.tcl

#List of memory files referenced in the Bender package manifest
MEM_FILES := $(shell bender update && bender script flist -n -t memory)
MEM_FILES_GEN_SCRIPT = generated/mem_files.tcl
#List of .xdc constraint files referenced in the Bender package manifest
CONSTRAINTS := $(shell bender update && bender script flist -n -t constraints)
CONSTRAINTS_GEN_SCRIPT = generated/constraints.tcl
#Verilator .vlt config files reference in the Bender package manifest
VLT_FILES := $(TOP_DIR)/build_sys/lint_default.vlt $(filter %.vlt, $(shell bender update && bender script flist -t verilator))
#Verilator CPP files
VLT_CPP_FILES = $(filter %.cpp %.c, $(shell bender update && bender script flist -t verilator))
ifdef OOC
MIN_T_OOC = -t $(OOC)
else
MIN_T_OOC =
endif

TOP_MODULE_SIM ?= $(TOP_MODULE)
TOP_MODULE_SYNTH ?= $(TOP_MODULE)

default: dryrun

#Whenever a bender package manifest has changed, bender update needs to be run.
.PHONY: bender_update
bender_update:
	bender update

#Rule to generate TCL 'sub' script that adds constraint files to the project
.PHONY: constraints
constraints: $(CONSTRAINTS)
	mkdir -p generated
	$(RM) -f $(CONSTRAINTS_GEN_SCRIPT)
	$(foreach constraint, $^, echo add_files -fileset constrs_1 $(constraint) >> $(CONSTRAINTS_GEN_SCRIPT))
ifdef OOC
	$(foreach constraint, $^, echo set_property USED_IN {synthesis out_of_context} [get_files $(constraint)] >> $(CONSTRAINTS_GEN_SCRIPT))
endif

#Rule to generate TCL 'sub' script that adds memory files to the project
.PHONY: mem_files
mem_files: $(MEM_FILES)
	mkdir -p generated
	$(RM) -f $(MEM_FILES_GEN_SCRIPT)
	$(foreach mem_file, $(MEM_FILES), cp $(mem_file) generated/ && echo add_files -norecurse $(mem_file) >> $(MEM_FILES_GEN_SCRIPT))

.PHONY: force
force :

#Pattern rule for memory files: Go to the memory file's directory and run Make there.
%.mem : force
	$(MAKE) -C $(@D)

#Rule to generate TCL 'sub' script that adds HDL source files to the project
$(BENDER_GEN_SCRIPT): bender_update
	mkdir -p generated
	bender script $(MIN_T_OOC) vivado > $(BENDER_GEN_SCRIPT)

#dryrun just creates the vivado project/component, but doesn't kick-off synthesis or implementation.
#synth generates the project/component and synthesizes it.
#impl generates the project/component, synthesizes it and implements it.
.PHONY: synth dryrun
dryrun synth impl: $(BENDER_GEN_SCRIPT) mem_files constraints
	vivado -nolog -nojournal -mode batch -source $(VIVADO_TCL) \
	-tclargs -project generated/project -cmd $@ -part $(PART) \
	-sources $(BENDER_GEN_SCRIPT) -constraints $(CONSTRAINTS_GEN_SCRIPT) \
	-mem_files $(MEM_FILES_GEN_SCRIPT) -outputDir generated -top $(TOP_MODULE_SYNTH)

#Runs verilator lint on the project/component
.PHONY: lint
lint:
	@echo $(VLT_FILES)  #FYI only.
	@bender script $(MIN_T_OOC) verilator #FYI only.
	verilator --lint-only $(VERILATOR_CPPFLAGS) $(VERILATOR_LDFLAGS) --top-module $(TOP_MODULE_SIM) --Wall $(VLT_FILES) `bender script $(MIN_T_OOC) verilator | tr '\n' ' '`
	@echo "Done. If no issues are found, verilator completes silently"

#Build verilator model/testbench for project.
.PHONY: sim
sim: mem_files
	@echo $(VLT_FILES)  #FYI only.
	@bender script $(MIN_T_OOC) verilator #FYI only.
	mkdir -p generated
	verilator $(VERILATOR_CPPFLAGS) $(VERILATOR_LDFLAGS) --top-module $(TOP_MODULE_SIM) -Wall -cc --trace-fst --exe -Os -x-assign 0 --build --prefix Vmodel \
	--Mdir generated $(VLT_FILES) $(VLT_CPP_FILES) `bender script $(MIN_T_OOC) verilator | tr '\n' ' '`

#A rule to download the generated bitstream to target.
.PHONY: run
run:
	vivado -nolog -nojournal -mode batch -source $(PRG_BITSTREAM_TCL) -tclargs -bitstream generated/project.runs/impl_1/*.bit

.PHONY: clean
clean:
	$(RM) -f *.log
	$(RM) -rf generated
